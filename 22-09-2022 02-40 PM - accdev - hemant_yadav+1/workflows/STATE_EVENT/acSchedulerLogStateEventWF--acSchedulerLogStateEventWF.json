{"checkIfJitScheduler":{"connectors":[{"exitPortType":"TrueStep","nodeId":"upsertIntoSchedulerLog"},{"exitPortType":"FalseStep","nodeId":"fetchJobsForBatchScheduler"}],"name":"checkIfJitScheduler","description":"checkIfJitScheduler","processRule":"contextVar.toRunModelName==='JitScheduler'","nodeType":"DECISION"},"checkIfTechsToBeFetched":{"connectors":[{"exitPortType":"TrueStep","nodeId":"fetchTechsForComparison"},{"exitPortType":"FalseStep","nodeId":"end"}],"name":"checkIfTechsToBeFetched","description":"checkIfTechsToBeFetched","processRule":"typeof contextVar.techsToBeFetchedSchedulers!=='undefined' && contextVar.techsToBeFetchedSchedulers.length>0","nodeType":"DECISION"},"fetchJobsForBatchScheduler":{"connectors":[{"exitPortType":"NextStep","nodeId":"processFetchedJobs"}],"contextChangePermitted":true,"processId":"schedulerLogStateEventFetchJobsWF","ignoreSubContext":true,"name":"fetchJobsForBatchScheduler","description":"fetchJobsForBatchScheduler","inputVarMap":{"filter":"filter","taskIdList":"taskIdList","taskTypeIdList":"taskTypeIdList","endDate":"endDate","workflowCall":"workflowCall","regionIdList":"regionIdList","currentDate":"currentDate","statusIds":"statusIds","startDate":"startDate"},"outputVarMap":{"jobs":"jobs","sites":"sites"},"nodeType":"WORKFLOW"},"checkIfSchedulersToMoveInProgress":{"connectors":[{"exitPortType":"TrueStep","nodeId":"getSchedulerSettingData"},{"exitPortType":"FalseStep","nodeId":"end"}],"name":"checkIfSchedulersToMoveInProgress","description":"checkIfSchedulersToMoveInProgress","processRule":"typeof contextVar.schedulersToMoveInProgress !== 'undefined' && contextVar.schedulersToMoveInProgress.length > 0","nodeType":"DECISION"},"start":{"connectors":[{"exitPortType":"NextStep","nodeId":"logContextVar"}],"name":"start","description":"Start","nodeType":"START"},"logContextVar":{"connectors":[{"exitPortType":"NextStep","nodeId":"processModelData"}],"processId":"featureLoggerWF","name":"logContextVar","description":"logContextVar","inputVarMap":{"featureName":"featureName","extraMsgStateEvent":"extraMsg"},"id":"logContextVar","outputVarMap":{},"nodeType":"WORKFLOW"},"upsertIntoSchedulerLog":{"connectors":[{"exitPortType":"NextStep","nodeId":"checkIfSchedulerToRun"}],"processId":"schedulerLogModelWF","name":"upsertIntoSchedulerLog","description":"upsertIntoSchedulerLog","inputVarMap":{"schedulerLog":"schedulerLog"},"outputVarMap":{},"nodeType":"WORKFLOW"},"setCurrentRecordsData":{"connectors":[{"exitPortType":"NextStep","nodeId":"checkIfMoreRecordsToLoop"}],"contextChangePermitted":true,"name":"setCurrentRecordsData","description":"set the current record to be looped","processRule":"{ contextVar.schedulerToTechsMap[contextVar.currentSchedulerLogId] = { originalFilteredTechIds: contextVar.originalFilteredTechIds, technicians: contextVar.technicians }; contextVar.currentSchedulerLogIndex++; contextVar.currentSchedulerLogId = contextVar.currentSchedulerLogIndex < contextVar.totalSchedulersToLoop ? contextVar.techsToBeFetchedSchedulers[contextVar.currentSchedulerLogIndex].id : undefined; }","nodeType":"PROCESS","jsEngine":"es6"},"fetchQueuedAndInProgressSchedulers":{"filter":"filter","models":["schedulerLog"],"connectors":[{"exitPortType":"NextStep","nodeId":"setQueuedSchedulersData"}],"columns":{"modelName":"schedulerLog.modelName","createdDate":"schedulerLog.createdDate","context":"schedulerLog.context","schedulerId":"schedulerLog.schedulerId","id":"schedulerLog.id","schedulerType":"schedulerLog.schedulerType","status":"schedulerLog.status"},"name":"fetchQueuedAndInProgressSchedulers","orderBy":"createdDate ASC","description":"fetchQueuedAndInProgressSchedulers","inputVarMap":{"schedulerLogFilter":"filter","id":"id"},"outputVarMap":{"data":"activeSchedulerData"},"batchSize":1000,"nodeType":"QUERY"},"setCurrentSchedulersData":{"connectors":[{"exitPortType":"NextStep","nodeId":"checkIfJitScheduler"}],"contextChangePermitted":true,"name":"setCurrentSchedulersData","description":"set the data for current scheduler to be looped","processRule":"{ /* if there is any scheduler to be run, set it's context in the contextVar so that it can be sent to the scheduler node */ let currentTime = new Date().toISOString().replace('T', ' ').replace('Z', ''); let endTime = new Date(); contextVar.acPrebookDays = contextVar.schedulerSettingData[0].acPrebookDays; endTime.setDate(endTime.getDate() + contextVar.acPrebookDays); contextVar.schedulerLog[0] = contextVar.schedulersToMoveInProgress[contextVar.currentSchedulerToRunIndex++]; contextVar.schedulerLog[0].status = 'schedulerLogInProgress'; contextVar.schedulerLog[0].startTime = currentTime; contextVar.schedulerLog[0].endTime = endTime; for (const key in contextVar.schedulerLog[0].context) { contextVar[key] = contextVar.schedulerLog[0].context[key]; } /*setting these separately so that we can differentiate between the current schedulerLog's record and the schedulerLog record which will get triggered next*/ contextVar.toRunSchedulerId = contextVar.schedulerLog[0].schedulerId; contextVar.defaultInputContext = { currentSchedulerLogId: contextVar.schedulerLog[0].id }; contextVar.toRunTechnicians = contextVar.schedulerLog[0]?.context?.schedulerTriggerContext?.technicians; contextVar.toRunModelName = contextVar.schedulerLog[0].modelName; /*This filter is set to be used in 'schedulerLogStateEventFetchJobsWF' workflow*/ if (typeof contextVar.schedulerLog[0].context.filter !== 'undefined' && contextVar.schedulerLog[0].context.filter !== '') { contextVar.filter = contextVar.schedulerLog[0].context.filter + ' AND {$id} IN {@loopArray}'; } else { contextVar.filter = '{$id} IN {@loopArray}'; } /*Checking if the start date is in past, if yes setting it to current date so that the scheduler never schedules any tasks in past*/ /* Skipping the logic to add 1 hour incase of JIT */ if (contextVar.toRunModelName === 'JitScheduler') { if (new Date(contextVar.startDate) < new Date()) { contextVar.startDate = new Date(); contextVar.startDate.setSeconds(0, 0); contextVar.startDate = contextVar.startDate.toISOString().replace('T', ' ').replace('Z', ''); } } else { let date60MinsInFuture = new Date(new Date().getTime() + 60 * 60000); if (new Date(contextVar.startDate) < date60MinsInFuture) { contextVar.startDate = date60MinsInFuture; contextVar.startDate.setSeconds(0, 0); contextVar.startDate = contextVar.startDate.toISOString().replace('T', ' ').replace('Z', ''); } } }","nodeType":"PROCESS","jsEngine":"es6"},"workflowNodes":["start","processModelData","checkIfCurrentSchedulerInProgressOrSkipped","fetchQueuedAndInProgressSchedulers","setQueuedSchedulersData","checkIfTechsToBeFetched","fetchTechsForComparison","setCurrentRecordsData","checkIfMoreRecordsToLoop","compareTechsWithInProgressAndQueuedSchedulersZRule","checkIfSchedulersToMoveInProgress","getSchedulerSettingData","setCurrentSchedulersData","checkIfJitScheduler","fetchJobsForBatchScheduler","processFetchedJobs","checkIfSchedulerToRun","upsertIntoSchedulerLog","callSchedulerEvent","checkIfMoreSchedulersToLoop","logContextVar","end"],"fetchTechsForComparison":{"connectors":[{"exitPortType":"NextStep","nodeId":"setCurrentRecordsData"}],"contextChangePermitted":true,"processId":"taskSchedulingBatchSchedulerFetchTechnicianWF","ignoreSubContext":true,"name":"fetchTechsForComparison","description":"fetchTechsForComparison","inputVarMap":{"currentSchedulerLogId":"currentSchedulerLogId"},"outputVarMap":{"originalFilteredTechIds":"originalFilteredTechIds","technicians":"technicians"},"nodeType":"WORKFLOW"},"callSchedulerEvent":{"eventId":"executeSchedulerProcessEvent","connectors":[{"exitPortType":"NextStep","nodeId":"checkIfMoreSchedulersToLoop"}],"contextChangePermitted":true,"ignoreSubContext":true,"name":"callSchedulerEvent","description":"callSchedulerEvent","inputVarMap":{"defaultInputContext":"defaultInputContext","toRunSchedulerId":"schedulerId","toRunModelName":"modelName","endDate":"endDate","jobs":"jobs","sites":"sites","version":"version","toRunTechnicians":"technicians","startDate":"startDate"},"outputVarMap":{},"nodeType":"PUBLISH"},"getSchedulerSettingData":{"models":["schedulerSetting"],"connectors":[{"exitPortType":"NextStep","nodeId":"setCurrentSchedulersData"}],"columns":{"schedulerSettingUseSkills":"schedulerSetting.useSkills","acPrebookDays":"schedulerSetting.acPrebookDays"},"name":"getSchedulerSettingData","description":"getSchedulerSettingData","distinct":true,"inputVarMap":{},"outputVarMap":{"data":"schedulerSettingData"},"nodeType":"QUERY","getCount":true},"checkIfCurrentSchedulerInProgressOrSkipped":{"connectors":[{"exitPortType":"TrueStep","nodeId":"end"},{"exitPortType":"FalseStep","nodeId":"fetchQueuedAndInProgressSchedulers"}],"name":"checkIfCurrentSchedulerInProgressOrSkipped","description":"checkIfCurrentSchedulerInProgressOrSkipped","processRule":"contextVar.status === 'schedulerLogInProgress'","nodeType":"DECISION"},"workflowContext":{"mergeSchedulerType":["missedSST","longRunningTask","slaJeopardyTask","criticalTask","criticalTaskNoAvailability","criticalTasksBumpedOutTasks","technicianLeaveTasks"],"schedulerLogsToSkip":[],"schedulersToMoveInProgress":[],"featureName":"batchScheduler","currentSchedulerToRunIndex":0,"workflowCall":"secondSchedulerLogStateEvent","extraMsgStateEvent":"SCHEDULER LOG STATE EVENT 2: schedulerLogStateEventWF call","version":"V2","skippedMessages":{"noTasks":"noTasks","duplicate":"duplicate"},"schedulerToTechsMap":{},"schedulerLog":[],"mergeDataSchedulerType":["longRunningTask","slaJeopardyTask","criticalTask","criticalTaskNoAvailability","criticalTasksBumpedOutTasks","technicianLeaveTasks"],"techsToBeFetchedSchedulers":[],"currentSchedulerLogIndex":0},"checkIfSchedulerToRun":{"connectors":[{"exitPortType":"TrueStep","nodeId":"callSchedulerEvent"},{"exitPortType":"FalseStep","nodeId":"checkIfMoreSchedulersToLoop"}],"name":"checkIfSchedulerToRun","description":"Check if scheduler to be moved to in progress","processRule":"contextVar.schedulerLog.length > 0 && contextVar.schedulerLog[0].status === 'schedulerLogInProgress'","nodeType":"DECISION"},"setQueuedSchedulersData":{"connectors":[{"exitPortType":"NextStep","nodeId":"checkIfTechsToBeFetched"}],"contextChangePermitted":true,"name":"setQueuedSchedulersData","description":"setQueuedSchedulersData","processRule":"{ const statuses = { schedulerLogInProgress: 'schedulerLogInProgress', schedulerLogQueued: 'schedulerLogQueued', schedulerLogSkipped: 'schedulerLogSkipped' }; /*Skipping schedulers does not make sense in case of parallel scheduling as a scheduler which can be run due to non-overlapping of any data might get dealyed if it gets merged with any scheduler which has overlapping data. */ if (contextVar.data.status === statuses.schedulerLogQueued) { contextVar.techsToBeFetchedSchedulers = [contextVar.data]; } else { contextVar.techsToBeFetchedSchedulers = contextVar.activeSchedulerData.length > 0 ? contextVar.activeSchedulerData.filter(log => log.status === statuses.schedulerLogQueued) : []; } contextVar.totalSchedulersToLoop = contextVar.techsToBeFetchedSchedulers.length; if (contextVar.totalSchedulersToLoop > 0) { contextVar.currentSchedulerLogId = contextVar.techsToBeFetchedSchedulers[0].id; } }","nodeType":"PROCESS","jsEngine":"es6"},"checkIfMoreSchedulersToLoop":{"connectors":[{"exitPortType":"TrueStep","nodeId":"getSchedulerSettingData"},{"exitPortType":"FalseStep","nodeId":"end"}],"name":"checkIfMoreSchedulersToLoop","description":"Check if more scheduler records are to be looped","processRule":"(contextVar.currentSchedulerToRunIndex < contextVar.schedulersToMoveInProgress.length)","nodeType":"DECISION"},"processFetchedJobs":{"connectors":[{"exitPortType":"NextStep","nodeId":"upsertIntoSchedulerLog"}],"contextChangePermitted":true,"name":"processFetchedJobs","description":"processFetchedJobs","processRule":"{ if (typeof contextVar.jobs !== 'undefined' && contextVar.jobs.length > 0) { if (typeof contextVar.schedulerLog[0].context['schedulerTriggerContext'] === 'undefined') contextVar.schedulerLog[0].context['schedulerTriggerContext'] = {}; contextVar.schedulerLog[0].context['schedulerTriggerContext']['jobs'] = contextVar.jobs; contextVar.schedulerLog[0].context['schedulerTriggerContext']['sites'] = contextVar.sites; } else { contextVar.schedulerLog[0].status = 'schedulerLogSkipped'; contextVar.schedulerLog[0].message = contextVar.skippedMessages.noTasks; contextVar.schedulerLog[0].result = []; contextVar.schedulerLog[0].unassignedJobs = []; } if (typeof contextVar.schedulerSettingData != 'undefined' && contextVar.schedulerSettingData.length > 0) { contextVar.acPrebookDays = contextVar.schedulerSettingData[0].acPrebookDays; } let currentTime = new Date().toISOString().replace('T', ' ').replace('Z', ''); contextVar.schedulerLog[0] = contextVar.schedulersToMoveInProgress[contextVar.currentSchedulerToRunIndex++]; contextVar.schedulerLog[0].status = 'schedulerLogInProgress'; contextVar.schedulerLog[0].startTime = currentTime; contextVar.endTime = new Date(currentTime); contextVar.endTime.setDate(contextVar.endTime.getDate() + contextVar.acPrebookDays + 1); contextVar.endTime = contextVar.endTime.toISOString().replace('T', ' ').replace('Z', ''); contextVar.schedulerLog[0].endTime = contextVar.endTime; }","nodeType":"PROCESS","jsEngine":"es6"},"end":{"name":"end","description":"End","inputVarMap":{},"outputVarMap":{},"nodeType":"END"},"processModelData":{"connectors":[{"exitPortType":"NextStep","nodeId":"checkIfCurrentSchedulerInProgressOrSkipped"}],"contextChangePermitted":true,"name":"processModelData","description":"processModelData","processRule":"{ for (const key in contextVar.data) { contextVar[key] = contextVar.data[key]; } if (contextVar.data.status === 'schedulerLogQueued') { contextVar.schedulerLogFilter = '{$schedulerLog.status}=\"schedulerLogInProgress\"'; } else { contextVar.schedulerLogFilter = '({$schedulerLog.status}=\"schedulerLogInProgress\" || {$schedulerLog.status}=\"schedulerLogQueued\") && {$schedulerLog.id}!={@id}'; } }","nodeType":"PROCESS","jsEngine":"es6"},"checkIfMoreRecordsToLoop":{"connectors":[{"exitPortType":"TrueStep","nodeId":"fetchTechsForComparison"},{"exitPortType":"FalseStep","nodeId":"compareTechsWithInProgressAndQueuedSchedulersZRule"}],"name":"checkIfMoreRecordsToLoop","description":"Check if more records are to be looped","processRule":"(contextVar.currentSchedulerLogIndex < contextVar.totalSchedulersToLoop)","nodeType":"DECISION"},"compareTechsWithInProgressAndQueuedSchedulersZRule":{"connectors":[{"exitPortType":"NextStep","nodeId":"checkIfSchedulersToMoveInProgress"}],"contextChangePermitted":true,"name":"compareTechsWithInProgressAndQueuedSchedulersZRule","description":"compareTechsWithInProgressAndQueuedSchedulersZRule","processRule":"@9F0LV1OJF1","nodeType":"PROCESS","jsEngine":"es6"}}